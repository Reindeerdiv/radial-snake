[{]: <region> (header)
# Step 2: Creating a game engine basis
[}]: #
[{]: <region> (body)
Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:

[{]: <helper> (diff_step 2.1)
#### Step 2.1: Create basic game view

##### Added views/game.html
```diff
@@ -0,0 +1,10 @@
+â”Š  â”Š 1â”Š<!DOCTYPE html>
+â”Š  â”Š 2â”Š<html>
+â”Š  â”Š 3â”Š  <head>
+â”Š  â”Š 4â”Š    <title>radial snake</title>
+â”Š  â”Š 5â”Š  </head>
+â”Š  â”Š 6â”Š
+â”Š  â”Š 7â”Š  <body>
+â”Š  â”Š 8â”Š    <canvas id="gameCanvas" tabindex="0"></canvas>
+â”Š  â”Š 9â”Š  </body>
+â”Š  â”Š10â”Š</html>ðŸš«â†µ
```
[}]: #

In the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).

> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above

Just to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:

[{]: <helper> (diff_step 2.2)
#### Step 2.2: Create basic game stylesheet

##### Added resources/styles/game.css
```diff
@@ -0,0 +1,6 @@
+â”Š â”Š1â”Š#gameCanvas {
+â”Š â”Š2â”Š  display: block;
+â”Š â”Š3â”Š  margin: auto;
+â”Š â”Š4â”Š  border-style: solid;
+â”Š â”Š5â”Š  border-width: 1px;
+â”Š â”Š6â”Š}ðŸš«â†µ
```

##### Changed views/game.html
```diff
@@ -2,6 +2,9 @@
 â”Š 2â”Š 2â”Š<html>
 â”Š 3â”Š 3â”Š  <head>
 â”Š 4â”Š 4â”Š    <title>radial snake</title>
+â”Š  â”Š 5â”Š
+â”Š  â”Š 6â”Š    <!-- Styles -->
+â”Š  â”Š 7â”Š    <link rel="stylesheet" type="text/css" href="/styles/game.css">
 â”Š 5â”Š 8â”Š  </head>
 â”Š 6â”Š 9â”Š
 â”Š 7â”Š10â”Š  <body>
```
[}]: #

> Note that every asset we create should be declared in the HTML file in order for it to take effect

To build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:

    resources$ mkdir libs
    resources$ cd libs
    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js
    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js

And load them in the game's HTML file's header:

[{]: <helper> (diff_step 2.3 views/game.html)
#### Step 2.3: Add jquery and underscore libs

##### Changed views/game.html
```diff
@@ -3,6 +3,10 @@
 â”Š 3â”Š 3â”Š  <head>
 â”Š 4â”Š 4â”Š    <title>radial snake</title>
 â”Š 5â”Š 5â”Š
+â”Š  â”Š 6â”Š    <!-- Libs -->
+â”Š  â”Š 7â”Š    <script type="text/javascript" src="/libs/jquery-2.1.1.js"></script>
+â”Š  â”Š 8â”Š    <script type="text/javascript" src="/libs/underscore.js"></script>
+â”Š  â”Š 9â”Š
 â”Š 6â”Š10â”Š    <!-- Styles -->
 â”Š 7â”Š11â”Š    <link rel="stylesheet" type="text/css" href="/styles/game.css">
 â”Š 8â”Š12â”Š  </head>
```
[}]: #

Now, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:

[{]: <helper> (diff_step 2.4)
#### Step 2.4: Add engine namespace

##### Added resources/scripts/namespaces.js
```diff
@@ -0,0 +1 @@
+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ
```

##### Changed views/game.html
```diff
@@ -7,6 +7,9 @@
 â”Š 7â”Š 7â”Š    <script type="text/javascript" src="/libs/jquery-2.1.1.js"></script>
 â”Š 8â”Š 8â”Š    <script type="text/javascript" src="/libs/underscore.js"></script>
 â”Š 9â”Š 9â”Š
+â”Š  â”Š10â”Š    <!-- Scripts -->
+â”Š  â”Š11â”Š    <script type="text/javascript" src="/scripts/namespaces.js"></script>
+â”Š  â”Š12â”Š
 â”Š10â”Š13â”Š    <!-- Styles -->
 â”Š11â”Š14â”Š    <link rel="stylesheet" type="text/css" href="/styles/game.css">
 â”Š12â”Š15â”Š  </head>
```
[}]: #

The first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.

The main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.

When everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.

![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)

> You can find plenty of details and information about what "game loop" means simply by typing in on Google.

A game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:

[{]: <helper> (diff_step 2.5)
#### Step 2.5: Create a game basis

##### Added resources/scripts/engine/game.js
```diff
@@ -0,0 +1,112 @@
+â”Š   â”Š  1â”ŠEngine.Game = class Game {
+â”Š   â”Š  2â”Š  // The frequency of which each frame will be drawn in milliseconds
+â”Š   â”Š  3â”Š  get fps() {
+â”Š   â”Š  4â”Š    return 1000 / 60;
+â”Š   â”Š  5â”Š  }
+â”Š   â”Š  6â”Š
+â”Š   â”Š  7â”Š  // Game's run speed.
+â”Š   â”Š  8â”Š  // A lower value will make it run slower and a higher value will make it run faster
+â”Š   â”Š  9â”Š  get speed() {
+â”Š   â”Š 10â”Š    return 1;
+â”Š   â”Š 11â”Š  }
+â”Š   â”Š 12â”Š
+â”Š   â”Š 13â”Š  constructor(canvas, debugging) {
+â”Š   â”Š 14â”Š    this.canvas = canvas;
+â”Š   â”Š 15â”Š    this.debugging = debugging;
+â”Š   â”Š 16â”Š    this.lastUpdate = this.creation = new Date().getTime();
+â”Š   â”Š 17â”Š
+â”Š   â”Š 18â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some
+â”Š   â”Š 19â”Š    // unexpected behaviors
+â”Š   â”Š 20â”Š    canvas.width = 1280;
+â”Š   â”Š 21â”Š    canvas.height = 720;
+â”Š   â”Š 22â”Š    // Canvas will be focused once game page is loaded so all events will automatically
+â”Š   â”Š 23â”Š    // be captured by it
+â”Š   â”Š 24â”Š    canvas.focus();
+â”Š   â”Š 25â”Š
+â”Š   â”Š 26â”Š    // We want to focus on the canvas once we press on it
+â”Š   â”Š 27â”Š    canvas.addEventListener("mousedown", canvas.focus.bind(canvas), false);
+â”Š   â”Š 28â”Š
+â”Š   â”Š 29â”Š    this.assets = {};
+â”Š   â”Š 30â”Š    this.events = new Map();
+â”Š   â”Š 31â”Š    this.context = canvas.getContext("2d");
+â”Š   â”Š 32â”Š    this.bufferedCanvas = document.createElement("canvas");
+â”Š   â”Š 33â”Š    this.bufferedContext = this.bufferedCanvas.getContext("2d");
+â”Š   â”Š 34â”Š    this.bufferedCanvas.width = canvas.width;
+â”Š   â”Š 35â”Š    this.bufferedCanvas.height = canvas.height;
+â”Š   â”Š 36â”Š  }
+â”Š   â”Š 37â”Š
+â”Š   â”Š 38â”Š  draw() {
+â”Š   â”Š 39â”Š    // If debugging, don't use double buffer so we can see rendering in real time
+â”Š   â”Š 40â”Š    if (this.debugging) {
+â”Š   â”Š 41â”Š      this.context.restore();
+â”Š   â”Š 42â”Š      this.context.fillStyle = "black";
+â”Š   â”Š 43â”Š      this.context.save();
+â”Š   â”Š 44â”Š      this.context.beginPath();
+â”Š   â”Š 45â”Š      this.context.rect(0, 0, this.canvas.width, this.canvas.height);
+â”Š   â”Š 46â”Š      this.context.fill();
+â”Š   â”Š 47â”Š    }
+â”Š   â”Š 48â”Š    // If not debugging, use double buffer to prevent flickering
+â”Š   â”Š 49â”Š    else {
+â”Š   â”Š 50â”Š      this.bufferedContext.restore();
+â”Š   â”Š 51â”Š      this.bufferedContext.fillStyle = "black";
+â”Š   â”Š 52â”Š      this.bufferedContext.save();
+â”Š   â”Š 53â”Š      this.bufferedContext.beginPath();
+â”Š   â”Š 54â”Š      this.bufferedContext.rect(0, 0, this.canvas.width, this.canvas.height);
+â”Š   â”Š 55â”Š      this.bufferedContext.fill();
+â”Š   â”Š 56â”Š      this.context.drawImage(this.bufferedCanvas, 0, 0);
+â”Š   â”Š 57â”Š    }
+â”Š   â”Š 58â”Š  }
+â”Š   â”Š 59â”Š
+â”Š   â”Š 60â”Š  update() {
+â”Š   â”Š 61â”Š    // Calculate the time elapsed
+â”Š   â”Š 62â”Š    let lastUpdate = this.lastUpdate;
+â”Š   â”Š 63â”Š    let currUpdate = this.lastUpdate = new Date().getTime();
+â”Š   â”Š 64â”Š    let span = currUpdate - lastUpdate;
+â”Š   â”Š 65â”Š    this.updateScreen(span / this.speed);
+â”Š   â”Š 66â”Š  }
+â”Š   â”Š 67â”Š
+â”Š   â”Š 68â”Š  // The main loop of the game
+â”Š   â”Š 69â”Š  loop() {
+â”Š   â”Š 70â”Š    // If paused, don't run loop. The canvas will remain as is
+â”Š   â”Š 71â”Š    if (!this.playing) return;
+â”Š   â”Š 72â”Š
+â”Š   â”Š 73â”Š    setTimeout(() => {
+â”Š   â”Š 74â”Š      this.draw();
+â”Š   â”Š 75â”Š      this.update();
+â”Š   â”Š 76â”Š      this.loop();
+â”Š   â”Š 77â”Š    }, this.fps);
+â”Š   â”Š 78â”Š  }
+â”Š   â”Š 79â”Š
+â”Š   â”Š 80â”Š  play() {
+â”Š   â”Š 81â”Š    this.playing = true;
+â”Š   â”Š 82â”Š    this.loop();
+â”Š   â”Š 83â”Š  }
+â”Š   â”Š 84â”Š
+â”Š   â”Š 85â”Š  pause() {
+â”Š   â”Š 86â”Š    this.playing = false;
+â”Š   â”Š 87â”Š  }
+â”Š   â”Š 88â”Š
+â”Š   â”Š 89â”Š  // Defines global assets
+â”Š   â”Š 90â”Š  extendAssets(assets) {
+â”Š   â”Š 91â”Š    _.extend(this.assets, assets);
+â”Š   â”Š 92â”Š  }
+â”Š   â”Š 93â”Š
+â”Š   â”Š 94â”Š  // Disposes global assets
+â”Š   â”Š 95â”Š  clearAssets() {
+â”Š   â”Š 96â”Š    this.assets = {};
+â”Š   â”Š 97â”Š  }
+â”Š   â”Š 98â”Š
+â”Š   â”Š 99â”Š  // Adds event listener for game canvas
+â”Š   â”Š100â”Š  addEventListener(type, listener, target) {
+â”Š   â”Š101â”Š    let boundListener = listener.bind(target);
+â”Š   â”Š102â”Š    this.events.set(listener, boundListener);
+â”Š   â”Š103â”Š    this.canvas.addEventListener(type, boundListener, false);
+â”Š   â”Š104â”Š  }
+â”Š   â”Š105â”Š
+â”Š   â”Š106â”Š  // Removes event listener from game canvas
+â”Š   â”Š107â”Š  removeEventListener(type, listener) {
+â”Š   â”Š108â”Š    let boundListener = this.events.get(listener);
+â”Š   â”Š109â”Š    this.events.delete(listener);
+â”Š   â”Š110â”Š    this.canvas.removeEventListener(type, boundListener, false);
+â”Š   â”Š111â”Š  }
+â”Š   â”Š112â”Š};ðŸš«â†µ
```

##### Changed views/game.html
```diff
@@ -9,6 +9,7 @@
 â”Š 9â”Š 9â”Š
 â”Š10â”Š10â”Š    <!-- Scripts -->
 â”Š11â”Š11â”Š    <script type="text/javascript" src="/scripts/namespaces.js"></script>
+â”Š  â”Š12â”Š    <script type="text/javascript" src="/scripts/engine/game.js"></script>
 â”Š12â”Š13â”Š
 â”Š13â”Š14â”Š    <!-- Styles -->
 â”Š14â”Š15â”Š    <link rel="stylesheet" type="text/css" href="/styles/game.css">
```
[}]: #

The only thing it's doing right now is only drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw some custom stuff. I just want to point out that in the `draw` method I used a very handy technique called [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering), where I first draw everything on a virtual canvas which is not visible to us, and once it's finished, I the result on the main canvas. It behaves the same way React's [virtual DOM](https://www.npmjs.com/package/react-dom) behaves like, and it will prevent our game from stuttering. To start running the game, we first need to wait for the DOM content to initialize, and once its ready we gonna create a new game instance and call the `play` method:

[{]: <helper> (diff_step 2.6)
#### Step 2.6: Create game entry point

##### Added resources/scripts/main.js
```diff
@@ -0,0 +1,4 @@
+â”Š â”Š1â”Šdocument.addEventListener("DOMContentLoaded", function(event) {
+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById("gameCanvas"), false);
+â”Š â”Š3â”Š  game.play();
+â”Š â”Š4â”Š});ðŸš«â†µ
```

##### Changed views/game.html
```diff
@@ -10,6 +10,7 @@
 â”Š10â”Š10â”Š    <!-- Scripts -->
 â”Š11â”Š11â”Š    <script type="text/javascript" src="/scripts/namespaces.js"></script>
 â”Š12â”Š12â”Š    <script type="text/javascript" src="/scripts/engine/game.js"></script>
+â”Š  â”Š13â”Š    <script type="text/javascript" src="/scripts/main.js"></script>
 â”Š13â”Š14â”Š
 â”Š14â”Š15â”Š    <!-- Styles -->
 â”Š15â”Š16â”Š    <link rel="stylesheet" type="text/css" href="/styles/game.css">
```
[}]: #

This will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.

The next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:

[{]: <helper> (diff_step 2.7)
#### Step 2.7: Add key states manager

##### Added resources/scripts/engine/key_states.js
```diff
@@ -0,0 +1,20 @@
+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {
+â”Š  â”Š 2â”Š  constructor() {
+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index
+â”Š  â”Š 4â”Š    this.states = new Array(255);
+â”Š  â”Š 5â”Š  }
+â”Š  â”Š 6â”Š
+â”Š  â”Š 7â”Š  get(k) {
+â”Š  â”Š 8â”Š    return this.states[k];
+â”Š  â”Š 9â”Š  }
+â”Š  â”Š10â”Š
+â”Š  â”Š11â”Š  // This should be called once we press a key
+â”Š  â”Š12â”Š  add(k) {
+â”Š  â”Š13â”Š    this.states[k] = true;
+â”Š  â”Š14â”Š  }
+â”Š  â”Š15â”Š
+â”Š  â”Š16â”Š  // This should be called once we release a key
+â”Š  â”Š17â”Š  remove(k) {
+â”Š  â”Š18â”Š    this.states[k] = false;
+â”Š  â”Š19â”Š  }
+â”Š  â”Š20â”Š};ðŸš«â†µ
```

##### Changed views/game.html
```diff
@@ -9,6 +9,7 @@
 â”Š 9â”Š 9â”Š
 â”Š10â”Š10â”Š    <!-- Scripts -->
 â”Š11â”Š11â”Š    <script type="text/javascript" src="/scripts/namespaces.js"></script>
+â”Š  â”Š12â”Š    <script type="text/javascript" src="/scripts/engine/key_states.js"></script>
 â”Š12â”Š13â”Š    <script type="text/javascript" src="/scripts/engine/game.js"></script>
 â”Š13â”Š14â”Š    <script type="text/javascript" src="/scripts/main.js"></script>
```
[}]: #

Now that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:

[{]: <helper> (diff_step 2.8)
#### Step 2.8: Register key presses

##### Changed resources/scripts/engine/game.js
```diff
@@ -15,7 +15,7 @@
 â”Š15â”Š15â”Š    this.debugging = debugging;
 â”Š16â”Š16â”Š    this.lastUpdate = this.creation = new Date().getTime();
 â”Š17â”Š17â”Š
-â”Š18â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some
+â”Š  â”Š18â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some
 â”Š19â”Š19â”Š    // unexpected behaviors
 â”Š20â”Š20â”Š    canvas.width = 1280;
 â”Š21â”Š21â”Š    canvas.height = 720;
```
```diff
@@ -25,9 +25,13 @@
 â”Š25â”Š25â”Š
 â”Š26â”Š26â”Š    // We want to focus on the canvas once we press on it
 â”Š27â”Š27â”Š    canvas.addEventListener("mousedown", canvas.focus.bind(canvas), false);
+â”Š  â”Š28â”Š    // Key flags will be registered by the "KeyStates" instance
+â”Š  â”Š29â”Š    canvas.addEventListener("keydown", onKeyDown.bind(this), false);
+â”Š  â”Š30â”Š    canvas.addEventListener("keyup", onKeyUp.bind(this), false);
 â”Š28â”Š31â”Š
 â”Š29â”Š32â”Š    this.assets = {};
 â”Š30â”Š33â”Š    this.events = new Map();
+â”Š  â”Š34â”Š    this.keyStates = new Engine.KeyStates();
 â”Š31â”Š35â”Š    this.context = canvas.getContext("2d");
 â”Š32â”Š36â”Š    this.bufferedCanvas = document.createElement("canvas");
 â”Š33â”Š37â”Š    this.bufferedContext = this.bufferedCanvas.getContext("2d");
```
```diff
@@ -109,4 +113,19 @@
 â”Š109â”Š113â”Š    this.events.delete(listener);
 â”Š110â”Š114â”Š    this.canvas.removeEventListener(type, boundListener, false);
 â”Š111â”Š115â”Š  }
-â”Š112â”Š   â”Š};ðŸš«â†µ
+â”Š   â”Š116â”Š};
+â”Š   â”Š117â”Š
+â”Š   â”Š118â”Šfunction onKeyDown(e) {
+â”Š   â”Š119â”Š  // Once we're focused on the canvas, we want nothing else to happen
+â”Š   â”Š120â”Š  // besides events the game is listening to. For example, when we press
+â”Š   â”Š121â”Š  // the arrow keys, this will prevent the screen from scrolling
+â”Š   â”Š122â”Š  e.preventDefault();
+â”Š   â”Š123â”Š  // Register key press
+â”Š   â”Š124â”Š  this.keyStates.add(e.keyCode);
+â”Š   â”Š125â”Š}
+â”Š   â”Š126â”Š
+â”Š   â”Š127â”Šfunction onKeyUp(e) {
+â”Š   â”Š128â”Š  e.preventDefault();
+â”Š   â”Š129â”Š  // Register key release
+â”Š   â”Š130â”Š  this.keyStates.remove(e.keyCode);
+â”Š   â”Š131â”Š}
```
[}]: #

A 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:

- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.
- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.

![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)

As I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:

[{]: <helper> (diff_step 2.9)
#### Step 2.9: Add screen layer

##### Added resources/scripts/engine/layer.js
```diff
@@ -0,0 +1,43 @@
+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {
+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas
+â”Š  â”Š 3â”Š  get width() {
+â”Š  â”Š 4â”Š    return this.canvas.width;
+â”Š  â”Š 5â”Š  }
+â”Š  â”Š 6â”Š
+â”Š  â”Š 7â”Š  get height() {
+â”Š  â”Š 8â”Š    return this.canvas.height;
+â”Š  â”Š 9â”Š  }
+â”Š  â”Š10â”Š
+â”Š  â”Š11â”Š  // A hash of "eventName" : "handlerName" which should be overrided by user
+â”Š  â”Š12â”Š  get events() {
+â”Š  â”Š13â”Š    return {};
+â”Š  â”Š14â”Š  }
+â”Š  â”Š15â”Š
+â”Š  â”Š16â”Š  constructor(screen) {
+â”Š  â”Š17â”Š    this.age = 0;
+â”Š  â”Š18â”Š    this.creation = new Date().getTime();
+â”Š  â”Š19â”Š    this.screen = screen;
+â”Š  â”Š20â”Š    this.game = screen.game;
+â”Š  â”Š21â”Š    this.assets = screen.assets;
+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;
+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;
+â”Š  â”Š24â”Š  }
+â”Š  â”Š25â”Š
+â”Š  â”Š26â”Š  update(span) {
+â”Š  â”Š27â”Š  }
+â”Š  â”Š28â”Š
+â”Š  â”Š29â”Š  draw(context) {
+â”Š  â”Š30â”Š  }
+â”Š  â”Š31â”Š
+â”Š  â”Š32â”Š  initEventListeners() {
+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {
+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);
+â”Š  â”Š35â”Š    });
+â”Š  â”Š36â”Š  }
+â”Š  â”Š37â”Š
+â”Š  â”Š38â”Š  disposeEventListeners() {
+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {
+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);
+â”Š  â”Š41â”Š    });
+â”Š  â”Š42â”Š  }
+â”Š  â”Š43â”Š};ðŸš«â†µ
```

##### Changed views/game.html
```diff
@@ -10,6 +10,7 @@
 â”Š10â”Š10â”Š    <!-- Scripts -->
 â”Š11â”Š11â”Š    <script type="text/javascript" src="/scripts/namespaces.js"></script>
 â”Š12â”Š12â”Š    <script type="text/javascript" src="/scripts/engine/key_states.js"></script>
+â”Š  â”Š13â”Š    <script type="text/javascript" src="/scripts/engine/layer.js"></script>
 â”Š13â”Š14â”Š    <script type="text/javascript" src="/scripts/engine/game.js"></script>
 â”Š14â”Š15â”Š    <script type="text/javascript" src="/scripts/main.js"></script>
```
[}]: #

Same thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:

[{]: <helper> (diff_step 2.10)
#### Step 2.10: Add game screen

##### Added resources/scripts/engine/screen.js
```diff
@@ -0,0 +1,85 @@
+â”Š  â”Š 1â”ŠEngine.Screen = class Screen {
+â”Š  â”Š 2â”Š  // The dimensions of the screen are correlated to dimensions of the canvas
+â”Š  â”Š 3â”Š  get width() {
+â”Š  â”Š 4â”Š    return this.canvas.width;
+â”Š  â”Š 5â”Š  }
+â”Š  â”Š 6â”Š
+â”Š  â”Š 7â”Š  get height() {
+â”Š  â”Š 8â”Š    return this.canvas.height;
+â”Š  â”Š 9â”Š  }
+â”Š  â”Š10â”Š
+â”Š  â”Š11â”Š  // A hash of "eventName" : "handlerName" which should be overrided by user
+â”Š  â”Š12â”Š  get events() {
+â”Š  â”Š13â”Š    return {};
+â”Š  â”Š14â”Š  }
+â”Š  â”Š15â”Š
+â”Š  â”Š16â”Š  constructor(game) {
+â”Š  â”Š17â”Š    this.age = 0;
+â”Š  â”Š18â”Š    this.creation = new Date().getTime();
+â”Š  â”Š19â”Š    this.game = game;
+â”Š  â”Š20â”Š    this.canvas = game.canvas;
+â”Š  â”Š21â”Š    this.keyStates = game.keyStates;
+â”Š  â”Š22â”Š    this.assets = _.clone(game.assets);
+â”Š  â”Š23â”Š    this.layers = [];
+â”Š  â”Š24â”Š  }
+â”Š  â”Š25â”Š
+â”Š  â”Š26â”Š  // A custom initialization function should be implemented by child-class
+â”Š  â”Š27â”Š  initialize() {
+â”Š  â”Š28â”Š    return this;
+â”Š  â”Š29â”Š  }
+â”Š  â”Š30â”Š
+â”Š  â”Š31â”Š  // Updates each layer
+â”Š  â”Š32â”Š  update(span) {
+â”Š  â”Š33â”Š    this.layers.forEach(layer => {
+â”Š  â”Š34â”Š      layer.age += span;
+â”Š  â”Š35â”Š      layer.update(span);
+â”Š  â”Š36â”Š    });
+â”Š  â”Š37â”Š  }
+â”Š  â”Š38â”Š
+â”Š  â”Š39â”Š  // Draws each layer
+â”Š  â”Š40â”Š  draw(context) {
+â”Š  â”Š41â”Š    this.layers.forEach(layer => {
+â”Š  â”Š42â”Š      layer.draw(context);
+â”Š  â”Š43â”Š    });
+â”Š  â”Š44â”Š  }
+â”Š  â”Š45â”Š
+â”Š  â”Š46â”Š  // Push a new layer to the top of the layers stack
+â”Š  â”Š47â”Š  appendLayer(Layer, ...layerArgs) {
+â”Š  â”Š48â”Š    let layer = new Layer(this, ...layerArgs);
+â”Š  â”Š49â”Š    this.layers.push(layer);
+â”Š  â”Š50â”Š    layer.initEventListeners();
+â”Š  â”Š51â”Š  }
+â”Š  â”Š52â”Š
+â”Š  â”Š53â”Š  // Push a new layer to the bottom of the layers stack
+â”Š  â”Š54â”Š  prependLayer(Layer, ...layerArgs) {
+â”Š  â”Š55â”Š    let layer = new Layer(this, ...layerArgs);
+â”Š  â”Š56â”Š    this.layers.unshift(layer);
+â”Š  â”Š57â”Š    layer.initEventListeners();
+â”Š  â”Š58â”Š  }
+â”Š  â”Š59â”Š
+â”Š  â”Š60â”Š  // Removes the given layer from the layers stack
+â”Š  â”Š61â”Š  removeLayer(layer) {
+â”Š  â”Š62â”Š    this.layers = _.without(this.layers, layer);
+â”Š  â”Š63â”Š    layer.disposeEventListeners();
+â”Š  â”Š64â”Š  }
+â”Š  â”Š65â”Š
+â”Š  â”Š66â”Š  initEventListeners() {
+â”Š  â”Š67â”Š    _.each(this.events, (listener, event) => {
+â”Š  â”Š68â”Š      this.game.addEventListener(event, this[listener], this);
+â”Š  â”Š69â”Š    });
+â”Š  â”Š70â”Š
+â”Š  â”Š71â”Š    this.layers.forEach(layer => {
+â”Š  â”Š72â”Š      layer.initEventListeners();
+â”Š  â”Š73â”Š    });
+â”Š  â”Š74â”Š  }
+â”Š  â”Š75â”Š
+â”Š  â”Š76â”Š  disposeEventListeners() {
+â”Š  â”Š77â”Š    _.each(this.events, (listener, event) => {
+â”Š  â”Š78â”Š      this.game.removeEventListener(event, this[listener], this);
+â”Š  â”Š79â”Š    });
+â”Š  â”Š80â”Š
+â”Š  â”Š81â”Š    this.layers.forEach(layer => {
+â”Š  â”Š82â”Š      layer.disposeEventListeners();
+â”Š  â”Š83â”Š    });
+â”Š  â”Š84â”Š  }
+â”Š  â”Š85â”Š};ðŸš«â†µ
```

##### Changed views/game.html
```diff
@@ -11,6 +11,7 @@
 â”Š11â”Š11â”Š    <script type="text/javascript" src="/scripts/namespaces.js"></script>
 â”Š12â”Š12â”Š    <script type="text/javascript" src="/scripts/engine/key_states.js"></script>
 â”Š13â”Š13â”Š    <script type="text/javascript" src="/scripts/engine/layer.js"></script>
+â”Š  â”Š14â”Š    <script type="text/javascript" src="/scripts/engine/screen.js"></script>
 â”Š14â”Š15â”Š    <script type="text/javascript" src="/scripts/engine/game.js"></script>
 â”Š15â”Š16â”Š    <script type="text/javascript" src="/scripts/main.js"></script>
```
[}]: #

Now that we have the `screen` class available for us, let's apply it to the main game loop:

[{]: <helper> (diff_step 2.11)
#### Step 2.11: Draw and update screen in game loop

##### Changed resources/scripts/engine/game.js
```diff
@@ -31,6 +31,7 @@
 â”Š31â”Š31â”Š
 â”Š32â”Š32â”Š    this.assets = {};
 â”Š33â”Š33â”Š    this.events = new Map();
+â”Š  â”Š34â”Š    this.screen = new Engine.Screen(this);
 â”Š34â”Š35â”Š    this.keyStates = new Engine.KeyStates();
 â”Š35â”Š36â”Š    this.context = canvas.getContext("2d");
 â”Š36â”Š37â”Š    this.bufferedCanvas = document.createElement("canvas");
```
```diff
@@ -48,6 +49,7 @@
 â”Š48â”Š49â”Š      this.context.beginPath();
 â”Š49â”Š50â”Š      this.context.rect(0, 0, this.canvas.width, this.canvas.height);
 â”Š50â”Š51â”Š      this.context.fill();
+â”Š  â”Š52â”Š      this.drawScreen(this.context);
 â”Š51â”Š53â”Š    }
 â”Š52â”Š54â”Š    // If not debugging, use double buffer to prevent flickering
 â”Š53â”Š55â”Š    else {
```
```diff
@@ -57,10 +59,17 @@
 â”Š57â”Š59â”Š      this.bufferedContext.beginPath();
 â”Š58â”Š60â”Š      this.bufferedContext.rect(0, 0, this.canvas.width, this.canvas.height);
 â”Š59â”Š61â”Š      this.bufferedContext.fill();
+â”Š  â”Š62â”Š      this.drawScreen(this.bufferedContext);
 â”Š60â”Š63â”Š      this.context.drawImage(this.bufferedCanvas, 0, 0);
 â”Š61â”Š64â”Š    }
 â”Š62â”Š65â”Š  }
 â”Š63â”Š66â”Š
+â”Š  â”Š67â”Š  drawScreen(context) {
+â”Š  â”Š68â”Š    // If screen's assets are not yet loaded, don't draw it
+â”Š  â”Š69â”Š    if (this.screen.loading) return;
+â”Š  â”Š70â”Š    if (this.screen.draw) this.screen.draw(context);
+â”Š  â”Š71â”Š  }
+â”Š  â”Š72â”Š
 â”Š64â”Š73â”Š  update() {
 â”Š65â”Š74â”Š    // Calculate the time elapsed
 â”Š66â”Š75â”Š    let lastUpdate = this.lastUpdate;
```
```diff
@@ -69,6 +78,13 @@
 â”Š69â”Š78â”Š    this.updateScreen(span / this.speed);
 â”Š70â”Š79â”Š  }
 â”Š71â”Š80â”Š
+â”Š  â”Š81â”Š  updateScreen(span) {
+â”Š  â”Š82â”Š    this.screen.age += span;
+â”Š  â”Š83â”Š    // If screen's assets are not yet loaded, don't update it
+â”Š  â”Š84â”Š    if (this.screen.loading) return;
+â”Š  â”Š85â”Š    if (this.screen.update) this.screen.update(span);
+â”Š  â”Š86â”Š  }
+â”Š  â”Š87â”Š
 â”Š72â”Š88â”Š  // The main loop of the game
 â”Š73â”Š89â”Š  loop() {
 â”Š74â”Š90â”Š    // If paused, don't run loop. The canvas will remain as is
```
[}]: #

This step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:

[{]: <helper> (diff_step 2.12)
#### Step 2.12: Add assets loader

##### Added resources/scripts/engine/assets_loader.js
```diff
@@ -0,0 +1,13 @@
+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {
+â”Š  â”Š 2â”Š  constructor(next) {
+â”Š  â”Š 3â”Š    this.next = next;
+â”Š  â”Š 4â”Š  }
+â”Š  â”Š 5â”Š
+â”Š  â”Š 6â”Š  // Load texture
+â”Š  â”Š 7â”Š  texture(path) {
+â”Š  â”Š 8â”Š    let image = new Image();
+â”Š  â”Š 9â”Š    image.onload = this.next();
+â”Š  â”Š10â”Š    image.src = `${path}.png`;
+â”Š  â”Š11â”Š    return image;
+â”Š  â”Š12â”Š  }
+â”Š  â”Š13â”Š};ðŸš«â†µ
```

##### Changed views/game.html
```diff
@@ -12,6 +12,7 @@
 â”Š12â”Š12â”Š    <script type="text/javascript" src="/scripts/engine/key_states.js"></script>
 â”Š13â”Š13â”Š    <script type="text/javascript" src="/scripts/engine/layer.js"></script>
 â”Š14â”Š14â”Š    <script type="text/javascript" src="/scripts/engine/screen.js"></script>
+â”Š  â”Š15â”Š    <script type="text/javascript" src="/scripts/engine/assets_loader.js"></script>
 â”Š15â”Š16â”Š    <script type="text/javascript" src="/scripts/engine/game.js"></script>
 â”Š16â”Š17â”Š    <script type="text/javascript" src="/scripts/main.js"></script>
```
[}]: #

> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.

Now that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:

[{]: <helper> (diff_step 2.13)
#### Step 2.13: Add the ability to change and load screen

##### Changed resources/scripts/engine/game.js
```diff
@@ -106,6 +106,58 @@
 â”Š106â”Š106â”Š    this.playing = false;
 â”Š107â”Š107â”Š  }
 â”Š108â”Š108â”Š
+â”Š   â”Š109â”Š  changeScreen(Screen, ...screenArgs) {
+â”Š   â”Š110â”Š    // If there is a screen defined, dispose it first
+â”Š   â”Š111â”Š    if (this.screen) {
+â”Š   â”Š112â”Š      this.unloadScreen();
+â”Š   â”Š113â”Š      this.screen.disposeEventListeners();
+â”Š   â”Š114â”Š    }
+â”Š   â”Š115â”Š
+â”Š   â”Š116â”Š    this.screen = new Screen(this, ...screenArgs);
+â”Š   â”Š117â”Š
+â”Š   â”Š118â”Š    // Load screen assets
+â”Š   â”Š119â”Š    this.loadScreen(() => {
+â”Š   â”Š120â”Š      // Once assets are loaded, initialize event listeners
+â”Š   â”Š121â”Š      this.screen.initEventListeners();
+â”Š   â”Š122â”Š      // The "initialize" method is exactly the same as the constructor, only it runs
+â”Š   â”Š123â”Š      // once assets are available and event listeners are registered
+â”Š   â”Š124â”Š      this.screen.initialize(this, ...screenArgs);
+â”Š   â”Š125â”Š    });
+â”Š   â”Š126â”Š  }
+â”Š   â”Š127â”Š
+â”Š   â”Š128â”Š  // Loads screen assets and invokes callback once loading is finished
+â”Š   â”Š129â”Š  loadScreen(callback = _.noop) {
+â”Š   â”Š130â”Š    if (!this.screen.load) return callback();
+â”Š   â”Š131â”Š
+â”Š   â”Š132â”Š    this.screen.loading = true;
+â”Š   â”Š133â”Š    // The number of assets to load
+â”Š   â”Š134â”Š    let loadsize = 0;
+â”Š   â”Š135â”Š
+â”Š   â”Š136â”Š    // We use the "after" method because we want the following callback to be invoked
+â”Š   â”Š137â”Š    // only once all assets are loaded
+â”Š   â”Š138â”Š    let onload = _.after(loadsize, () => {
+â”Š   â”Š139â”Š      delete this.screen.loading;
+â”Š   â”Š140â”Š      callback();
+â”Š   â”Š141â”Š    });
+â”Š   â”Š142â”Š
+â”Š   â”Š143â”Š    // This object can load assets
+â”Š   â”Š144â”Š    let assetsLoader = new Engine.AssetsLoader(() => {
+â”Š   â”Š145â”Š      loadsize++;
+â”Š   â”Š146â”Š      return () => onload();
+â”Š   â”Š147â”Š    });
+â”Š   â”Š148â”Š
+â”Š   â”Š149â”Š    // The "load" method returns the assets loaded by the screen
+â”Š   â”Š150â”Š    let screenAssets = this.screen.load(assetsLoader);
+â”Š   â”Š151â”Š    // The returned assets will be available on screen's assets object
+â”Š   â”Š152â”Š    _.extend(this.screen.assets, screenAssets);
+â”Š   â”Š153â”Š  }
+â”Š   â”Š154â”Š
+â”Š   â”Š155â”Š  // Disposes screen assets
+â”Š   â”Š156â”Š  unloadScreen() {
+â”Š   â”Š157â”Š    let assetsNames = this.screen.unload && this.screen.unload();
+â”Š   â”Š158â”Š    _.omit(this.assets, assetsNames);
+â”Š   â”Š159â”Š  }
+â”Š   â”Š160â”Š
 â”Š109â”Š161â”Š  // Defines global assets
 â”Š110â”Š162â”Š  extendAssets(assets) {
 â”Š111â”Š163â”Š    _.extend(this.assets, assets);
```
[}]: #

Let's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:

[{]: <helper> (diff_step 2.14)
#### Step 2.14: Add test screen

##### Added resources/scripts/test_screen.js
```diff
@@ -0,0 +1,10 @@
+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {
+â”Š  â”Š 2â”Š  draw(context) {
+â”Š  â”Š 3â”Š    // A 20px sized "Georgia" font (Available natively)
+â”Š  â”Š 4â”Š    context.font = "20px Georgia";
+â”Š  â”Š 5â”Š    // The text should be colored white
+â”Š  â”Š 6â”Š    context.fillStyle = "white";
+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top
+â”Š  â”Š 8â”Š    context.fillText("This is a Test Screen", 50, 50);
+â”Š  â”Š 9â”Š  }
+â”Š  â”Š10â”Š};ðŸš«â†µ
```

##### Changed views/game.html
```diff
@@ -14,6 +14,7 @@
 â”Š14â”Š14â”Š    <script type="text/javascript" src="/scripts/engine/screen.js"></script>
 â”Š15â”Š15â”Š    <script type="text/javascript" src="/scripts/engine/assets_loader.js"></script>
 â”Š16â”Š16â”Š    <script type="text/javascript" src="/scripts/engine/game.js"></script>
+â”Š  â”Š17â”Š    <script type="text/javascript" src="/scripts/test_screen.js"></script>
 â”Š17â”Š18â”Š    <script type="text/javascript" src="/scripts/main.js"></script>
 â”Š18â”Š19â”Š
 â”Š19â”Š20â”Š    <!-- Styles -->
```
[}]: #

Now we will use the test screen by changing to it as we create an instance of the game:

[{]: <helper> (diff_step 2.15)
#### Step 2.15: Set test screen as the initial screen

##### Changed resources/scripts/main.js
```diff
@@ -1,4 +1,5 @@
 â”Š1â”Š1â”Šdocument.addEventListener("DOMContentLoaded", function(event) {
 â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById("gameCanvas"), false);
+â”Š â”Š3â”Š  game.changeScreen(TestScreen);
 â”Š3â”Š4â”Š  game.play();
 â”Š4â”Š5â”Š});ðŸš«â†µ
```
[}]: #

Once you will load the application you should see a black canvas with a white text saying:

    This is a test screen

It means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)
[}]: #
[{]: <region> (footer)
[{]: <helper> (nav_step)
| [< Previous Step](step1.md) | [Next Step >](step3.md) |
|:--------------------------------|--------------------------------:|
[}]: #
[}]: #